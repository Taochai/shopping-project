“逻辑过期 + 后台异步刷新” 的缓存方案，用于彻底避免缓存雪崩（以及缓存击穿）。  
✅ 核心思想：  
Redis 中缓存的数据 永不过期（物理不过期）  
但数据中包含一个 expireTime 字段（逻辑过期时间）  
请求只读缓存，不负责重建，由后台线程/异步任务定期检查并刷新即将过期或已过期的缓存。(异步刷新，建议自己定义线程池---线程池的实际使用场景)  

---

### ✅ 缓存雪崩解决方案：逻辑过期 + 异步刷新

#### 📌 问题
大量缓存同时过期 → 请求穿透到 DB → 数据库压力剧增（雪崩）

#### 🔧 核心思想
- **缓存永不过期（物理不过期）**
- 数据中包含 **逻辑过期时间**
- **请求只读缓存，不重建**
- **后台异步线程定期刷新**

#### 🛠 实现要点
1. **包装缓存结构**
   ```java
   class CachedData<T> {
       T data;
       LocalDateTime expireTime; // 逻辑过期时间
   }
   ```

2. **读缓存逻辑**
   - 未过期 → 直接返回
   - 已过期 → 返回旧数据 + 触发异步刷新（优雅降级）
   - 缓存为空 → 可触发首次异步加载

3. **异步刷新（@Async + 分布式锁）**
   - 加 Redis 锁防并发刷新
   - 从 DB 加载 → 更新缓存（无 Redis TTL）
   - 空值也缓存（防穿透）

4. **配置**
   - `@EnableAsync` + 自定义线程池
   - 刷新周期：如 5 分钟（逻辑过期时间）

#### ✅ 优势
- 彻底避免缓存雪崩 & 击穿  
- 请求零 DB 压力  
- 高可用：过期时仍返回旧数据

#### ⚠️ 注意
- 首次访问需处理冷启动（预热 or 异步加载）
- 监控刷新成功率
- 冷数据需定期清理（防 Redis 膨胀）

--- 

> 💡 一句话总结：**缓存永不过期，后台悄悄刷新，请求只读不写，雪崩无处可逃。**
